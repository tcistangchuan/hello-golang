- 应用场景

  ```
  缓存
  共享Session
  消息队列系统（解耦，异步处理，削峰/限流）
  分布式锁 
  ```

- Redis 分布式锁(在分布式系统环境下，一个方法在同一时间只能被一个机器的一个线程执行)

  ```
    加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。
    设置锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。
    解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。
  
  
  则加锁解锁伪代码如下：
  if (setnx(key, 1) == 1){
      expire(key, 300)
      try {
          //TODO 业务逻辑
          del(key)
      } catch {
          del(key)
      }
  }
  ```

- redis和memcached的区别

  ```
  1.redis拥有丰富的数据类型
  2.redis内存利用率高于memcached
  3.redis是单线程，memcache是多线程，大多数情况下,redis比memcached稍逊色
  4.memcached 没有原生集群模式，redis官方支持redis cluster 集群模式
  ```

- 为什么redis单线程模型也能效率这么高

  ```
  https://zhuanlan.zhihu.com/p/52600663
  
  1.纯内存数据库，读写数据非常快
  2.单线程,避免多线程的频繁的上下文切换带来的开销
  3.redis使用多路I/O复用技术。多个socket连接复用一个线程。
  4.高效的低层数据结构
  
  非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间
  
  
  提示：
  多路I/O复用，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
  与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。
  
  ```

- redis的数据结构和使用场景

  ```
  1.string:普通的set,get，可以用来做缓存，计数器，共享Session,分布式锁
  2.hash:类似于map,是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象，比如用户信息。
  3.list:实现原理就是双向链表，可用来做消息队列。
  4.set:是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。
  	应用：1.利用 Set 的交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能
  			 2.利用集合元素唯一性，可以统计访问网站的独立ip
  5.sorted set:Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。和Sets相比，Sorted Sets是将 Set 中的元素增加了一个权重参数 score。
  	应用：1.利用元素的权重，可以做排行榜应用
  			 2.延迟队列
  			 
  扩展：
  redis实现延迟队列：
    (1) 将任务的执行时间作为score，要执行的任务数据作为value，存放在zset中； 
  	(2) 用定时任务定时查询指定区间内的成员，可以用zrangebyscore key min max [WITHSCORES] [LIMIT] 命令来实现; 
  	(3) 如果最小的分数小于等于当前时间戳，就将该任务取出来执行，否则休眠一段时间后再查询
  ```

- redis刁难问题

  ```
  1.Redis分布式锁,如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
  解决：会造成死锁。用set指令的扩展，同时把setnx和expire合成一个指令。
  
  2.使用过Redis队列问题
  （1）异步队列怎么用的
   答：一般用生产消费者模式，list结构作为队列，rpush生产消息，lpop消费消息，当没有消息的时候要适当的sleep一下再重试；
   		也可以用blpop指令（移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止）。
   		
  （2）如何生产一次消费多次？
   答：用pub/sub 主题订阅者模式，可以实现1:n的消息队列，缺点就是生产的消息容易丢失，建议用专业的消息队列
  
  （3）延迟队列怎么做?
  	zrangebyscore key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员
   缺点：单个zset很难支持百万级别的延迟任务
   建议：用RabbitMQ,给延迟的消息任务设置TTL,TTL到期会把消息发送给消费者。
  ```

- Redis并发竞争key的解决方案

  ```
  并发竞争key这个问题简单讲就是：
  	同时有多个客户端去set一个key。
  
  解决方案：
  1.用分布式锁
  	在业务层进行控制，操作 redis 之前，先去申请一个分布式锁，拿到锁的才能操作。（分布式锁的实现方式很多，比如 ZooKeeper、Redis 等。）
  	
  2.用时间戳：
    由于上面举的例子，要求key的操作需要顺序执行，所以需要保存一个时间戳判断set顺序。
  
      系统A key 1 {ValueA 7:00}
      系统B key 1 { ValueB 7:05}
  
    假设系统B先抢到锁，将key1设置为{ValueB 7:05}。接下来系统A抢到锁，发现自己的key1的时间戳早于缓存中的时间戳（7:00<7:05），那就不做set操作了。
  
  3.用消息队列：
  在并发量过大的情况下,可以通过消息中间件进行处理,把并行读写进行串行化。
  ```

- Redis与Mysql双写一致性方案

  ```
  	先更新数据库，再删缓存。如果先删除缓存，再去更新数据库会造成数据库和缓存数据不一致。一个请求先删除缓存，另一个请求此时去读缓存，发现缓存不存在并创建了新的缓存，第一个请求这个时候再去更新数据，就造成了数据库和缓存不一致。
  	
    解决删除缓存失败问题：
    （1）往消息队列里面推消息，消费者去删除缓存，如果消费失败，消息中间件有重试机制
     (2)也可以订阅binlog,使用canal中间件监听数据库的修改，将数据推送给消息中间件，再用消费者去删除缓存。
  ```

- redis持久化

  ```
  Redis为了保证效率，数据缓存在了内存中，但是会周期性的把更新的数据写入磁盘或者把修改操作追加的记录文件中，以保证数据的持久化。Redis的持久化策略有两种：
    (1)RDB：定时以快照形式是直接把内存中的数据保存到一个dump.rdb的文件中。保存策略是，当Redis需要做持久化时，Redis会fork一个子进程，子进程将数据写到磁盘上的一个临时RDB文件中。当子进程完成写临时文件后，将原来的RDB替换掉。
    (2)AOF：把所有的对Redis的服务器进行修改的命令都以追加的方式存到一个文件里，命令的集合。
    
    区别：AOF持久化的文件大于RDB文件，同步速度会比rdb慢，但是服务器宕机后rdb方式会丢失数据。
    		 建议两种方式混合使用，全量同步用rdb，增量同步用aof。
    
  使用AOF做持久化，每一个写命令都通过write函数追加到appendonly.aof中。aof的默认策略是每秒钟同步一次，在这种配置下，就算发生故障停机，也最多丢失一秒钟的数据。 缺点是对于相同的数据集来说，AOF的文件体积通常要大于RDB文件的体积。根据所使用的同步策略，AOF的速度可能会慢于RDB。 Redis默认是快照RDB的持久化方式。对于主从同步来说，主从刚刚连接的时候，进行全量同步（RDB）；全同步结束后，进行增量同步(AOF)。
  ```

- redis-Pipeline(管道)

  参考：https://blog.csdn.net/u011489043/article/details/78769428

  ```
  管道（pipeline）可以一次性发送多条命令并在执行完后一次性将结果返回，pipeline 通过减少客户端与 redis 的通信次数来实现降低往返延时时间，而且 Pipeline 实现的原理是队列，而队列的原理是时先进先出，这样就保证数据的顺序性。
  ```
  
- Redis的事务（MULTI）

  ```
  MULTI，开始事务。
  命令入队。
  EXEC，执行事务。
  
  1.Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行集合中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。
  2.Redis事务没有隔离级别的概念，批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。
  3.Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。
  ```
  
- 管道和事务的区别

  ```
  pipeline中的命令是以队列发送到redis中执行的，但如果其他redis连接同时发送了命令，那么pipeline中的命令放到redis的排队执行队列中时可能会被拆开，即pipeline中的多个命令被其他命令插队。而事务不会被插队。
  ```
  
  
  
- redis集群

  ```
  参考：https://segmentfault.com/a/1190000022808576
  
  三种模式：
  （1）主从复制，当主数据库中的数据更新后，自动将更新的数据同步到从数据库上。优点读写分离，缺点不具备容错和恢复功能，主机宕机，或者从数据库宕机需要人工介入处理
   (2)哨兵模式，哨兵是一个独立的进程，作为进程。
   		哨兵模式的作用：
  			哨兵通过发送ping命令，监控主数据库和从数据库运行状态;
  			当哨兵监测到 主数据库 宕机，会自动将 从数据库 切换成 主数据库 ，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机；
  		优点：
  			哨兵模式是基于主从模式的，主从可以自动切换主机，系统更健壮，可用性更高(可以看作自动版的主从复制)。
  		缺点：但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存，并且很难支持在线扩容。
  （3）Cluster 集群模式（Redis官方）
  		优点：每台 Redis 节点上存储不同的数据，每个节点彼此互联，客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作。支持横向扩容。
  
  总结：Redis Sentinal（哨兵）着重于高可用。
  			Redis Cluster着眼于扩展性。
  ```
  
- ### Redis 的数据过期策略

  ```
  Redis 中数据过期策略采用定期删除+惰性删除策略
  
  - 定期删除策略：Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除。这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，非常消耗 CPU 资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用。
  
  - 惰性删除策略：在获取 key 时，先判断 key 是否过期，如果过期则删除。这种方式存在一个缺点：如果这个 key 一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间。
  
  - 这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的 key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除策略互补了为检查到的key，基本上满足了所有要求。但是有时候就是那么的巧，既没有被定时器抽取到，又没有被使用，这些数据又如何从内存中消失？没关系，还有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。
  ```

- Redis 数据淘汰策略

  ```
  (1)volatile-lru：从已设置过expire的数据集中挑选最近最少使用的数据淘汰
  (2)volatile-ttl：从已设置过expire的数据集中挑选将要过期的数据淘汰
  (3)volatile-random：从已设置过expire的数据集中任意选择数据淘汰
  (4)allkeys-lru：从数据集中挑选最近最少使用的数据淘汰
  (5)allkeys-random：从数据集中任意选择数据淘汰
  (6)no-enviction（驱逐）：禁止淘汰旧数据,返回错误
  ```

- Redis LRU算法实现

  ```
  常用LRU（Least recently used，最近最少使用）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。每当缓存命中（即缓存数据被访问），则将数据移到链表头部； 当链表满的时候，将链表尾部的数据丢弃。
  redis(LRU):
  Redis每次缓存命中都会更新缓存中的lru字段为当前秒级别的时间戳。Redis初始的实现算法很简单，随机从dict中取出五个key,淘汰一个lru字段值最小的。在3.0的时候，又改进了一版算法，首先第一次随机选取的key都会放入一个pool中(pool的大小为16),pool中的key是按lru大小顺序排列的。接下来每次随机选取的key的lru值必须小于pool中最小的lru才会继续放入，直到将pool放满。放满之后，每次如果有新的key需要放入，需要将pool中lru最大的一个key取出。淘汰的时候，直接从pool中选取一个lru最小的key然后将其淘汰
  ```

- Redis如何发现热点key

  ```
  1. 凭借经验，进行预估：例如提前知道了某个活动的开启，那么就将此Key作为热点Key。
  2. 服务端收集：在操作redis之前，加入一行代码进行数据统计。
  3. 抓包进行评估：Redis使用TCP协议与客户端进行通信，通信协议采用的是RESP，所以自己写程序监听端口也能进行拦截包进行解析。
  4. 在proxy层，对每一个 redis 请求进行收集上报。
  5. Redis自带命令查询：Redis4.0.4版本提供了redis-cli –hotkeys就能找出热点Key。（如果要用Redis自带命令查询时，要注意需要先把内存逐出策略设置为allkeys-lfu或者volatile-lfu，否则会返回错误。进入Redis中使用config set maxmemory-policy allkeys-lfu即可。）
  ```

- Redis的热点key解决方案

  ```
  1. 服务端缓存：即将热点数据缓存至服务端的内存中.(利用Redis自带的消息通知机制来保证Redis和服务端热点Key的数据一致性，对于热点Key客户端建立一个监听，当热点Key有更新操作的时候，服务端也随之更新。)
  2. 备份热点Key：即将热点Key+随机数，随机分配至Redis其他节点中。这样访问热点key的时候就不会全部命中到一台机器上了。
  ```





- Redis 五大数据类型实现原理

  ```
  redis的底层数据结构:
  https://www.cnblogs.com/ysocean/p/9080942.html
  https://www.cnblogs.com/ysocean/p/9102811.html
  ```

- 字符串

  ```
  字符串编码是int和SDS
  
  struct sdshdr{
       //等于 SDS 保存字符串的长度
       int len;
       //记录 buf 数组中未使用字节的数量
       int free;
       //字节数组，用于保存字符串的所有元素
       char buf[];
  }
  ```

  

- List(列表)

  ```
  3.2版本之前是linkedlist或者ziplist存储的
  当同时满足下面两个条件时，使用ziplist（压缩列表）编码：
  1、元素个数小于512个
  2、元素长度小于64字节
  
  linkedlist和ziplist的优缺点：
    （1）linkedlist便于在表的两端进行push和pop操作，但是双向链表的各个节点是单独的内存块，地址不连续，容易产生内存碎片。
    （2）ziplist由于是一整块连续的内存，存储效率很高，但不利于添加和删除操作，尤其是当ziplist很长的时候，一次重新分配造成的开销特别的大。
  
  3.2版本之后采用 quicklist 结合了双向链表和ziplist的优点，
  quicklist有两个配置参数比较重要：
  （1）list-max-ziplist-size 限制每个quicklist节点上的ziplist的大小
  （2）list-compress-depth 表示一个quicklist两端不被压缩的节点个数
  
  ```

- hash

  ```
  提供两种结构来存储：
  hashtable
  ziplist
  
  当同时满足下面两个条件时，使用ziplist（压缩列表）编码：
  1、键值对个数小于512个
  2、键值对长度小于64字节
  ```

- set

  ```
  集合对象的编码可以是 intset 或者 hashtable。
  当集合同时满足以下两个条件时，使用 intset 编码：
  1、集合对象中所有元素都是整数
  2、集合对象所有元素数量不超过512
  
  set 和list的最大的区别：
  list是有序的，set是无序的；list可以元素可以是重复的，set元素是不能重复的。
  ```

- Zset（有序集合）

  ```
  有序集合可以是 ziplist 或者 skiplist+hashtable。
  当有序集合对象同时满足以下两个条件时，对象使用 ziplist 编码：
  1、保存的元素数量小于128；
  2、保存的所有元素长度都小于64字节。
  
  1.ziplist 编码的有序集合对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员，第二个节点保存元素的分值。并且压缩列表内的集合元素按分值从小到大的顺序进行排列，小的放置在靠近表头的位置，大的放置在靠近表尾的位置。
  
  2.skiplist 编码一个 zset 结构同时包含一个字典和一个跳跃表：
  typedef struct zset{
       //跳跃表
       zskiplist *zsl;
       //字典
       dict *dict;
  } zset;
  　　字典的键保存元素的值，字典的值则保存元素的分值；跳跃表节点的 object 属性保存元素的成员，跳跃表节点的 score 属性保存元素的分值。跳跃表中的节点按照分值大小进行排序。
  
  　　这两种数据结构会通过指针来共享相同元素的成员和分值，所以不会产生重复成员和分值，造成内存的浪费。
  
  　　说明：其实有序集合单独使用字典或跳跃表其中一种数据结构都可以实现，但是这里使用两种数据结构组合起来，原因是假如我们单独使用 字典，虽然能以 O(1) 的时间复杂度查找成员的分值，但是因为字典是以无序的方式来保存集合元素，所以每次进行范围操作的时候都要进行排序；假如我们单独使用跳跃表来实现，虽然能执行范围操作，但是查找操作有 O(1)的复杂度变为了O(logN)。因此Redis使用了两种数据结构来共同实现有序集合。
  　　
  ```

  

- redis低层数据结构：

  ```
  1.intset:是整数值的集合。在内存分配上与ziplist类似，用一块连续的内存保存数组元素。
  typedef struct intset{
       //编码方式
       uint32_t encoding;
       //集合包含的元素数量
       uint32_t length;
       //保存元素的数组
       int8_t contents[];
   
  }intset;
  整数集合的每个元素都是 contents 数组的一个数据项，它们按照从小到大的顺序排列，并且不包含任何重复项。
  　①、升级
  　　当我们新增的元素类型比原集合元素类型的长度要大时，需要对整数集合进行升级，才能将新元素放入整数集合中。具体步骤：
  　　(1)、根据新元素类型，扩展整数集合底层数组的大小，并为新元素分配空间。
  　　(2)、将底层数组现有的所有元素都转成与新元素相同类型的元素，并将转换后的元素放到正确的位置，放置过程中，维持整个元素顺序都是有序的。
  　　(3)、将新元素添加到整数集合中（保证有序）。
  　　升级能极大地节省内存。
  　　②、降级
  　　整数集合不支持降级操作，一旦对数组进行了升级，编码就会一直保持升级后的状态。
  　　
  2.压缩列表（ziplist）是Redis为了节省内存而开发的，是由一系列特殊编码的连续内存块组成的顺序型数据结构，一个压缩列表可以包含任意多个节点（entry），每个节点可以保存一个字节数组或者一个整数值。　　
  
  ```

- Redis的rehash

  ```
  rehash:
    Redis的rehash 操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的，redis会维护维持一个索引计数器变量rehashidx来表示rehash的进度。
    这种渐进式的 rehash 避免了集中式rehash带来的庞大计算量和内存操作，但是需要注意的是redis在进行rehash的时候，正常的访问请求可能需要做多要访问两次hashtable（ht[0]， ht[1]），例如键值被rehash到新ht1，则需要先访问ht0，如果ht0中找不到，则去ht1中找。
  
  Redis的hash表被扩展的条件
    1.哈希表中保存的key数量超过了哈希表的大小.
    2.Redis服务器目前没有在执行BGSAVE命令（rdb）或BGREWRITEAOF命令，并且哈希表的负载因子大于等于1.
    3.Redis服务器目前在执行BGSAVE命令（rdb）或BGREWRITEAOF命令，并且哈希表的负载因子大于等于5.
    (负载因子=哈希表已保存节点数量 / 哈希表大小，当哈希表的负载因子小于0.1时，对哈希表执行收缩操作。)
  ```