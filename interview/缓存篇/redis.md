- redis和memcached的区别

  ```
  1.redis拥有更多的数据结构和数据操作
  2.redis内存利用率高于memcached
  3.redis是单线程，memcache是多线程，大多数情况下,redis比memcached稍逊色
  4.memcached 没有原生集群模式，redis官方支持redis cluster 集群模式
  ```

- 为什么redis单线程模型也能效率这么高

  ```
  https://zhuanlan.zhihu.com/p/52600663
  
  1.纯内存数据库，读写数据非常快
  2.单线程反而避免多线程的频繁的上下文切换和锁的开销
  3.redis使用多路I/O复用技术，可以处理并发的连接。多个socket连接复用一个线程。
  
  非阻塞IO 内部实现采用epoll，采用了epoll+自己实现的简单的事件框架。epoll中的读、写、关闭、连接都转化成了事件，然后利用epoll的多路复用特性，绝不在io上浪费一点时间
  
  
  提示：
  多路I/O复用，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。
  与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。
  
  ```

- redis的数据结构和使用场景

  ```
  1.string:普通的set,get，做简单的kv存储，计时器
  2.hash:类似于map,是一个 string 类型的 field（字段） 和 value（值） 的映射表，hash 特别适合用于存储对象。
  3.list:实现原理就是双向链表，可用来做消息队列，和最新消息列表等等。
  4.set:是 String 类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据。
  	应用：1.比如微博应用中，将用户关注的对象存在一个集合，把所有粉丝存在一个集合，可以实现共同关注，共同好友。
  			 2.利用集合元素唯一性，可以统计访问网站的独立ip
  5.sorted set:Redis 有序集合和集合一样也是 string 类型元素的集合,且不允许重复的成员。和Sets相比，Sorted Sets是将 Set 中的元素增加了一个权重参数 score。
  	应用：1.利用元素的权重，可以获取一个游戏里面的用户得分排行榜
  ```

- redis刁难问题

  ```
  1.Redis分布式锁,如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
  解决：会造成死锁。用set指令的扩展，同时把setnx和expire合成一个指令。
  
  2.使用过Redis队列问题
  （1）异步队列怎么用的
   答：一般用生产消费者模式，list结构作为队列，rpush生产消息，lpop消费消息，当没有消息的时候要适当的sleep一下再重试；
   		也可以用blpop指令（移出并获取列表的第一个元素， 如果列表没有元素会阻塞列表直到等待超时或发现可弹出元素为止）。
   		
  （2）如何生产一次消费多次？
   答：用pub/sub 主题订阅者模式，可以实现1:n的消息队列，缺点就是生产的消息容易丢失，建议用专业的消息队列
  
  （3）延迟队列怎么做?
  	zrangebyscore key min max [WITHSCORES] [LIMIT] 通过分数返回有序集合指定区间内的成员
   答：利用 Redis 的 sorted set 结构，使用 timeStamp 作为 score，比如你的任务是要延迟5分钟，那么就在当前时间上加5分钟作为 score ，轮询任务每秒只轮询 zrangebyscore 指定区间的任务，如果任务支持有误差，那么当没有扫描到有效数据的时候可以休眠对应时间再继续轮询。
   缺点：单个zset很难支持百万级别的延迟任务
   建议：用RabbitMQ,给延迟的消息任务设置TTL,TTL到期会自动转发到消费队列。
  ```

- redis持久化

  ```
  参考：https://segmentfault.com/a/1190000002906345
  ```

- redis-Pipeline(管道)

  参考：https://blog.csdn.net/u011489043/article/details/78769428

  ```
  redis 通常请求遵循以下步骤：
  	客户端向服务端发送一个查询请求，并监听 Socket 返回，通常是以阻塞模式，等待服务端响应。服务端处理命令，并将结果返回给客户端。
  
  管道（pipeline）可以一次性发送多条命令并在执行完后一次性将结果返回，pipeline 通过减少客户端与 redis 的通信次数来实现降低往返延时时间，而且 Pipeline 实现的原理是队列，而队列的原理是时先进先出，这样就保证数据的顺序性。
  ```

- redis集群

  ```
  参考：https://segmentfault.com/a/1190000022808576
  
  三种模式：
  （1）主从复制，优点读写分离，缺点不具备容错和恢复功能，主机宕机，或者slave断线需要人工介入
   (2)哨兵模式，哨兵是一个独立的进程，作为进程。
   		哨兵模式的作用：
  			通过发送命令，让 Redis 服务器返回监控其运行状态，包括主服务器和从服务器；
  			当哨兵监测到 master 宕机，会自动将 slave 切换成 master ，然后通过发布订阅模式通知其他的从服务器，修改配置文件，让它们切换主机；
  		优点：
  			哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。
  			主从可以自动切换，系统更健壮，可用性更高(可以看作自动版的主从复制)。
  		缺点：但是在这种模式下每台 Redis 服务器都存储相同的数据，很浪费内存。Redis较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。 	
  （3）Cluster 集群模式（Redis官方）
  		优点：每台 Redis 节点上存储不同的内容，客户端可以与任何一个节点相连接，然后就可以访问集群中的任何一个节点。对其进行存取和其他操作。支持横向扩容。
  
  总结：Redis Sentinal（哨兵）着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
  			Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储
  ```

- Redis 数据淘汰策略

  ```
  (1)volatile-lru：从已设置过expire的数据集中挑选最近最少使用的数据淘汰
  (2)volatile-ttl：从已设置过expire的数据集中挑选将要过期的数据淘汰
  (3)volatile-random：从已设置过expire的数据集中任意选择数据淘汰
  (4)allkeys-lru：从数据集中挑选最近最少使用的数据淘汰
  (5)allkeys-random：从数据集中任意选择数据淘汰
  (6)no-enviction（驱逐）：禁止淘汰旧数据,返回错误
  ```

- Redis skiplist（跳跃表）

  ```
  https://blog.csdn.net/weixin_41622183/article/details/91126155
  1.什么是跳跃表
  跳跃表是多层链表，每个节点维持几个指定到其他几个节点的指针，从而达到快速访问某个节点的目的。
  
  2.跳跃表的应用：
  redis实现有序集合
  
  ```

- zipList

  ```
  ziplist由于是一整块连续内存，所以存储效率很高。但是，它不利于修改操作，每次数据变动都会引发一次内存的realloc。特别是当ziplist长度很长的时候，一次realloc可能会导致大批量的数据拷贝，进一步降低性能。
  ```

- quicklist

  ```
  list的内部实现quicklist正是一个双向链表，quicklist的每个节点都是一个ziplist
  ```

  