- GC垃圾回收

  参考链接：https://lessisbetter.site/2019/10/20/go-gc-1-history-and-priciple

  ```
  一、三色标色法说明
  黑色：使用中的对象，已经被扫描过的对象
  灰色：表示被黑色对象直接引用的对象，但还没对他进行扫描
  白色：白色是对象初始化的颜色，如果扫描完成后，对象依然是白色的，说明此对象是垃圾对象（不再被使用的内存区域）。
  
  二、三色标记规则
  1.黑色不能指向白色对象。
  2.黑色可以指向灰色，灰色可以指向白色
  
  三、三色标记主要流程：(参考：https://segmentfault.com/a/1190000022030353)
  1.把所有对象放入白色标记集合
  2.（每个goroutine都有root对象），把root对象放入灰色集合
  3.遍历灰色集合，把灰色引用的对象从白色集合放入灰色集合，之后将遍历的灰色对象放入黑色集合
  4.重复上次遍历操作，直到灰色集合为空
  5.回收剩下的白色标记对象，也就是垃圾回收
  
  四、栈扫描之前，两个准备stw(stop the world) 和开启写屏障
  STW是为了暂停当前所有运行中的goroutine，进行一些准备工作
  写屏障：
  A.Next = B
  A.Next = &C{}
  用户线程执行完 A.Next = B 后，扫描线程把A标记为黑色，B标记为灰色，用户线程执行 A.Next = &C{} ，C是新对象，被标记为白色，由于A已经被扫描，不会重复扫描，所以C不会被标记为灰色，造成了黑色对象指向白色对象的情况，这违反了三色标记中的不变性规则，结果是C被认为是垃圾对象，最终被清扫掉，当访问C时会造成非法内存访问而Panic。
  写屏障可以解决这个问题，当对象引用树发生改变时，即对象指向关系发生变化时，将被指向的对象标记为灰色，维护了三色标记的约束：黑色对象不能直接引用白色对象，这避免了使用中的对象被释放。
  有写屏障后，用户线程执行 A.Next = &C{} 后，写屏障把C标记为灰色。
  
  五、并发标记
  并发垃圾回收的主要思想上文已经介绍，Go的垃圾回收为每个P都分配了一个gcMarker协程，用于并发标记对象，这样有些P在标记对象，而有些P上继续运行用户协程。
  Go的并发标记有4种运行模式，还没深入研究，这里举一个并发标记的场景：在goroutine的调度过程中，如果当前P上已经没有g可以执行，也偷不到g时，P就空闲下来了，这时候可以运行当前P的gcMarker协程。
  
  六、GC有3种触发方式：
  1.被动触发
    （1）情况一：在分配内存时，会判断当前的Heap内存分配量是否达到了触发一轮GC的阈值（每轮GC完成后，该阈值会被动态设置），如果超过阈值，则启动一轮GC。
    （2）情况二：使用系统监控，当超过两分钟没有产生任何 GC 时，强制触发 GC。
  2.手动触发。调用runtime.GC()强制启动一轮GC。
  
  七、GC调节参数
  Go为了保证使用GC的简洁性，只提供了一个参数GOGC，可以通过环境变量设置。一个开启gc的阀值。
  特殊值：off-关闭GC，0-代表持续进行垃圾回收，只用于调试。
  ```

  