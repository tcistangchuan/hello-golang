- 本文参考链接：

  ```
  https://juejin.cn/post/6844904176481206285
  https://www.jianshu.com/p/9e8d2eb152c8
  ```

- 逃逸分析

  ```
  1、如果函数内申请内存的变量在函数外部没有引用，则优先放到栈中；
  2、如果函数内申请内存的变量在函数外部存在引用，则必定放到堆中；
  
  注意：go 在编译阶段确立逃逸，并不是在运行时。
  ```

- 内存逃逸的原因

  ```
  函数退出后，在函数内申请内存的变量，仍然在函数外部被引用，就把它分配在堆上。
  ```

- 内存逃逸的带来的坏处：

  ```
  1.堆上分配内存比栈上要慢很多
  2.如果变量都分配到堆上，它可能会引起Go频繁地进行垃圾回收，频繁的垃圾回收会浪费cpu资源。
  
  总结：可以尽量把那些不需要分配到堆上的变量直接分配到栈上，堆上的变量少了，会减轻分配堆内存的开销，同时也会减少gc的压力，提高程序的运行速度。
  ```

- 能引起变量逃逸到堆上的典型情况：

  ```
  1.方法返回局部变量的指针，并且被函数外部引用
  解释：局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
  列子：
  // 这是上面提到的 "在方法内把局部变量指针返回" 的情况
  func foo(s string) *A {
   a := new(A) 
   a.s = s
   return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆
  }
  
  2.发送指针或者带有指针的值到channel中。
  解释：在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。
  
  3.在一个切片上存储指针或者带指针的值。
  解释：一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
  
  4.slice 在 append 时进行了扩容
  解释：slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
  
  5.调用interface类型上的方法。
  在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。
  
  6.尽管能够符合分配到栈的场景，但是其大小不能够在在编译时候确定的情况，也会分配到堆上
  ```

- 查看内存逃逸的情况

  ```
  go build -gcflags=-m
  ```

- 如何避免逃逸

  ```
  1.避免通过interface调用方法
  2.尽量初始化好切片的容量，避免扩容
  ```