```
事务隔离等级和mvcc实现原理参考：
https://cloud.tencent.com/developer/article/1417728

三种行锁（记录锁、间隙锁与临键锁）：
https://juejin.cn/post/6844903666420285454

快照读和当前读：
https://www.jianshu.com/p/27352449bcc0

快照读和当前读的实现方式：

当前读:
https://www.jianshu.com/p/eb3f56565b42
使用next-key锁(行记录锁+Gap间隙锁)实现
对主键或唯一索引，如果当前读时，where条件全部精确命中(=或者in)，这种场景本身就不会出现幻读，所以只会加行记录锁。
没有索引的列，当前读操作时，会加全表gap锁，生产环境要注意。
非唯一索引列，如果where条件部分命中(>、<、like等)或者全未命中，则会加附近Gap间隙锁。例如，某表数据如下，非唯一索引2,6,9,9,11,15。如下语句要操作非唯一索引列9的数据，gap锁将会锁定的列是(6,11]，该区间内无法插入数据

快照读：
https://www.jianshu.com/p/e6001dec58c8
快照读的实现方式：undolog和多版本并发控制MVCC
Read Committed隔离级别：每次select都生成一个快照读
Read Repeatable隔离级别：开启事务后第一个select语句才是快照读的地方，而不是一开启事务就快照读




#了解事务的ACID四大特性：
（1）原子性（Atomicity）：事务作为一个整体被执行，不能被拆分。
（2）一致性（Consistency）：对数据库的操作要么全部被执行，要么都不执行
（3）隔离性（Isolation）：多个事务并发执行，互相不影响。
（4）持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。
#了解事务的四大隔离等级：
（1）READ UNCOMMITED(未提交读)：事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也成为脏读。
（2）READ COMMITED (提交读，不可重复读)：一个事务开始时，只能看到已经提交的事务所做的修改。
因为两次执行同样的查询，可能会得到不一样的结果。(因为期间可能有其他事务已经对读取的数据进行了修改或者删除，这种现象叫不可重复读)
（3）REPEATABLE READ (可重复读)：该级别保证了在同一个事务中多次读取同样的记录的结果是一致的。
但是，可重复读隔离级别还是无法解决另一个幻读 的问题。
当之前的事务再次读 取该范围的记录时，会产生幻行。可重复读是Mysql 默认的事务隔离级别。
可重复读模式可能会导致幻读，因为无法感知其余事务，可能导致重复的插入。


可重复读实现原理：https://blog.csdn.net/sanyuesan0000/article/details/90235335

（4）SERIALIZABLE(可串行化)：
SERIALIZABLE是最高的隔离级别。它通过强制事务串行，避免了前面说的幻读问题。简单的来说，
SERIALIZABLE会在读的每一行数据上 都加上锁，所以可能导致大量的超时和锁征用问题。

#innodb如何解决幻读问题
解决：https://juejin.im/post/5c7912eee51d4547222f5d3c（汇总）
(1)MVCC：MVCC是通过在每行记录后面保存两个隐藏的列来实现的。这两个列，一个保存了行的创建时间，一个保存行的删除时间。
时间，是指版本号。每开始一个新的事务，系统版本号都会自动递增。查询时候创建时间和删除时间都要小于或者等于当前时间（版本号）。
参考：https://www.jianshu.com/p/f692d4f8a53e
(2)Gap Lock：间隙锁(select * from t_student where id>1 and id < 10 for update;)
(3)next-key Lock
```