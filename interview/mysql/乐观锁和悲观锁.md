- 乐观锁和悲观锁概念

  ```
  乐观锁和悲观锁是两种思想，用于解决并发场景下的数据竞争问题。
  
  乐观锁：乐观锁在操作数据时非常乐观，认为别人不会同时修改数据。因此乐观锁不会上锁，只是在执行更新的时候判断一下在此期间别人是否修改了数据：如果别人修改了数据则放弃操作，否则执行操作。
  
  悲观锁：悲观锁在操作数据时比较悲观，认为别人会同时修改数据。因此操作数据时直接把数据锁住，直到操作完成后才会释放锁；上锁期间其他人不能修改数据。
  ```

- 乐观锁和悲观锁实现方式

  ```
  悲观锁，用加锁的方式实现
  
  乐观锁，用CAS机制和版本号机制.
  
  1.CAS：（Compare and swap），即比较并交换。
  CAS操作逻辑如下：如果内存位置V的值等于预期的A值，则将该位置更新为新值B，否则不进行任何操作。许多CAS的操作是自旋的：如果操作不成功，会一直重试，直到操作成功为止。
  这里引出一个新的问题，既然CAS包含了Compare和Swap两个操作，它又如何保证原子性操作呢？答案是：CAS是由CPU支持的原子操作，其原子性是在硬件层面进行保证的。
  
  2.版本号机制
  版本号机制的基本思路是在数据中增加一个字段version，表示该数据的版本号，每当数据被修改，版本号加1。当某个线程查询数据时，将该数据的版本号一起查出来；当该线程更新数据时，判断当前版本号与之前读取的版本号是否一致，如果一致才进行操作。不一致就不更新。
  		//根据player_id查询玩家信息，包含version信息
      Player player = query("select coins, level, version from player where player_id = {0}", playerId);
      //根据玩家当前信息及其他信息，计算新的金币数
      Long newCoins = ……;
      //更新金币数，条件中增加对version的校验
      update("update player set coins = {0}, version = version + 1 where player_id = {1} and version = {2}", newCoins, playerId, player.version);
  ```

  

